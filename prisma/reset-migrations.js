const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log('üîÑ Resetting Prisma migrations for PostgreSQL...');

try {
  const migrationsDir = path.join(__dirname, 'migrations');

  // 1. Create backup of existing migrations if needed
  if (fs.existsSync(migrationsDir) && fs.readdirSync(migrationsDir).length > 0) {
    console.log('üì¶ Backing up existing migrations...');
    const backupDir = path.join(__dirname, 'migrations_backup_' + Date.now());
    fs.mkdirSync(backupDir, { recursive: true });
    execSync(`cp -r ${migrationsDir}/* ${backupDir}/`);
    console.log(`‚úÖ Migrations backed up to ${backupDir}`);
  }

  // 2. Remove all existing migrations
  if (fs.existsSync(migrationsDir)) {
    console.log('üóëÔ∏è Removing existing migrations...');
    execSync(`rm -rf ${migrationsDir}/*`);
  } else {
    fs.mkdirSync(migrationsDir, { recursive: true });
  }

  // 3. Ensure migration_lock.toml file exists with postgresql provider
  console.log('üìù Creating migration lock file...');
  fs.writeFileSync(
    path.join(migrationsDir, 'migration_lock.toml'),
    '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = "postgresql"\n'
  );

  // 4. Create a fresh migration
  console.log('üÜï Creating fresh PostgreSQL migration...');
  const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
  const migrationDir = path.join(migrationsDir, `${timestamp}_init`);
  fs.mkdirSync(migrationDir, { recursive: true });

  // 5. Write PostgreSQL migration file
  fs.writeFileSync(
    path.join(migrationDir, 'migration.sql'),
    `-- CreateTable
CREATE TABLE "Appointment" (
    "id" SERIAL PRIMARY KEY,
    "teaser" TEXT NOT NULL,
    "mainText" TEXT NOT NULL,
    "startDateTime" TIMESTAMP(3) NOT NULL,
    "endDateTime" TIMESTAMP(3),
    "street" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "recurringText" TEXT,
    "fileUrls" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,
    "processingDate" TIMESTAMP(3)
);`
  );

  console.log('‚úÖ Fresh migration created successfully');

  // 6. Update the schema.prisma to use postgresql
  console.log('üìù Updating schema.prisma to use PostgreSQL...');
  const schemaPath = path.join(__dirname, 'schema.prisma');
  let schemaContent = fs.readFileSync(schemaPath, 'utf8');

  // Make sure the datasource provider is postgresql
  schemaContent = schemaContent.replace(
    /datasource\s+db\s*{[^}]*provider\s*=\s*".*?"/s,
    'datasource db {\n  provider = "postgresql"'
  );

  // Ensure the generator provider is prisma-client-js
  schemaContent = schemaContent.replace(
    /generator\s+client\s*{[^}]*provider\s*=\s*".*?"/s,
    'generator client {\n  provider = "prisma-client-js"'
  );

  fs.writeFileSync(schemaPath, schemaContent);

  // 7. In production: create a .env file with DATABASE_URL if it doesn't exist
  if (process.env.NODE_ENV === 'production' && !fs.existsSync(path.join(__dirname, '..', '.env'))) {
    console.log('üìù Ensuring DATABASE_URL is available...');
    if (process.env.DATABASE_URL) {
      fs.writeFileSync(
        path.join(__dirname, '..', '.env'),
        `DATABASE_URL="${process.env.DATABASE_URL}"\n`
      );
    } else {
      console.warn('‚ö†Ô∏è No DATABASE_URL found in environment variables');
    }
  }

  // 8. Generate Prisma client
  console.log('üîß Generating Prisma client...');
  execSync('npx prisma generate', { stdio: 'inherit' });

  console.log('‚úÖ Migration reset complete!');

} catch (error) {
  console.error('‚ùå Error during migration reset:', error);
  process.exit(1);
}