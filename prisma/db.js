/**
 * Prisma database utilities for development and production
 */
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const MIGRATIONS_DIR = path.join(__dirname, 'migrations');
const SCHEMA_PATH = path.join(__dirname, 'schema.prisma');
const IS_VERCEL = process.env.VERCEL === '1';

/**
 * Validates the database connection string and environment
 */
function validateEnvironment() {
  if (!process.env.DATABASE_URL) {
    console.error('‚ùå No DATABASE_URL found in environment');
    console.error('Please set the DATABASE_URL environment variable');
    return false;
  }

  // Check for either postgres:// or postgresql:// format
  if (!process.env.DATABASE_URL.includes('postgres')) {
    console.error('‚ùå DATABASE_URL does not appear to be a PostgreSQL connection string');
    console.error('Please ensure your PostgreSQL connection string is correctly formatted');
    return false;
  }

  console.log('‚úÖ DATABASE_URL is properly set');
  return true;
}

/**
 * Ensures the schema.prisma file has the correct provider settings
 */
function validateSchema() {
  try {
    console.log('üìù Validating schema.prisma configuration...');
    let schemaContent = fs.readFileSync(SCHEMA_PATH, 'utf8');
    let updated = false;

    // Ensure datasource provider is postgresql
    if (!schemaContent.includes('provider = "postgresql"')) {
      schemaContent = schemaContent.replace(
        /datasource\s+db\s*{[^}]*provider\s*=\s*".*?"/s,
        'datasource db {\n  provider = "postgresql"'
      );
      updated = true;
    }

    // Ensure generator provider is prisma-client-js
    if (!schemaContent.includes('provider = "prisma-client-js"')) {
      schemaContent = schemaContent.replace(
        /generator\s+client\s*{[^}]*provider\s*=\s*".*?"/s,
        'generator client {\n  provider = "prisma-client-js"'
      );
      updated = true;
    }

    // Write changes if needed
    if (updated) {
      fs.writeFileSync(SCHEMA_PATH, schemaContent);
      console.log('‚úÖ Updated schema.prisma configuration');
    } else {
      console.log('‚úÖ Schema configuration is valid');
    }
    
    return true;
  } catch (error) {
    console.error('‚ùå Error validating schema:', error);
    return false;
  }
}

/**
 * Resets and recreates all migrations
 */
function resetMigrations() {
  try {
    console.log('üîÑ Resetting migrations directory...');
    
    // Make sure migrations directory exists
    if (!fs.existsSync(MIGRATIONS_DIR)) {
      fs.mkdirSync(MIGRATIONS_DIR, { recursive: true });
    }
    
    // Remove all existing migrations (except lock file)
    const migrationFiles = fs.readdirSync(MIGRATIONS_DIR)
      .filter(file => file !== 'migration_lock.toml');
    
    for (const file of migrationFiles) {
      const filePath = path.join(MIGRATIONS_DIR, file);
      if (fs.lstatSync(filePath).isDirectory()) {
        fs.rmSync(filePath, { recursive: true, force: true });
      } else if (file !== 'migration_lock.toml') {
        fs.unlinkSync(filePath);
      }
    }

    // Create or update the migration_lock.toml file
    console.log('üìù Creating migration lock file for PostgreSQL...');
    fs.writeFileSync(
      path.join(MIGRATIONS_DIR, 'migration_lock.toml'),
      '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = "postgresql"\n'
    );

    // Create a new migration directory
    const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
    const newMigrationDir = path.join(MIGRATIONS_DIR, `${timestamp}_init`);
    
    if (!fs.existsSync(newMigrationDir)) {
      fs.mkdirSync(newMigrationDir, { recursive: true });
    }

    // Write the migration SQL
    fs.writeFileSync(
      path.join(newMigrationDir, 'migration.sql'),
      `-- CreateTable
CREATE TABLE IF NOT EXISTS "Appointment" (
    "id" SERIAL PRIMARY KEY,
    "teaser" TEXT NOT NULL,
    "mainText" TEXT NOT NULL,
    "startDateTime" TIMESTAMP(3) NOT NULL,
    "endDateTime" TIMESTAMP(3),
    "street" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "recurringText" TEXT,
    "fileUrls" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,
    "processingDate" TIMESTAMP(3)
);`
    );

    console.log('‚úÖ Fresh migration created at', newMigrationDir);
    return true;
  } catch (error) {
    console.error('‚ùå Error resetting migrations:', error);
    return false;
  }
}

/**
 * Attempts to reset the PostgreSQL database (drop and recreate schema)
 */
async function resetDatabase() {
  try {
    console.log('üóëÔ∏è Attempting to reset PostgreSQL database...');

    // Create a temporary file to execute SQL directly
    const sqlPath = path.join(__dirname, 'reset.sql');
    fs.writeFileSync(sqlPath, `
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO public;
    `);

    try {
      // For Vercel, we use Prisma directly since psql might not be available
      // For local development, we can try both approaches
      
      if (IS_VERCEL) {
        console.log('Using Prisma for database reset (Vercel environment)');
        
        // Create a minimal prisma schema for reset
        const tempSchemaPath = path.join(__dirname, 'temp-schema.prisma');
        fs.writeFileSync(tempSchemaPath, `
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
generator client {
  provider = "prisma-client-js"
  output   = "./temp-client"
}
        `);
        
        // Generate a temporary client
        execSync(`npx prisma generate --schema=${tempSchemaPath}`, { stdio: 'inherit' });
        
        // Create a temporary script to execute the reset
        const resetScriptPath = path.join(__dirname, 'temp-reset.js');
        fs.writeFileSync(resetScriptPath, `
const { PrismaClient } = require('./temp-client');
const prisma = new PrismaClient();

async function main() {
  try {
    await prisma.$executeRawUnsafe('DROP SCHEMA IF EXISTS public CASCADE');
    await prisma.$executeRawUnsafe('CREATE SCHEMA public');
    await prisma.$executeRawUnsafe('GRANT ALL ON SCHEMA public TO postgres');
    await prisma.$executeRawUnsafe('GRANT ALL ON SCHEMA public TO public');
    console.log('‚úÖ Database reset successful');
  } catch (error) {
    console.error('‚ùå Failed to reset database:', error.message);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

main();
        `);
        
        // Run the script
        execSync(`node ${resetScriptPath}`, { stdio: 'inherit' });
        
        // Clean up temp files
        fs.unlinkSync(tempSchemaPath);
        fs.unlinkSync(resetScriptPath);
        fs.rmSync(path.join(__dirname, 'temp-client'), { recursive: true, force: true });
      } else {
        // Try psql first for local development
        try {
          console.log('Attempting database reset via psql...');
          execSync(`psql "${process.env.DATABASE_URL}" -f "${sqlPath}"`, { stdio: 'inherit' });
        } catch (psqlError) {
          console.log('psql not available, falling back to Prisma...');
          
          // Fall back to prisma db execute
          execSync(`npx prisma db execute --file=${sqlPath} --schema=${SCHEMA_PATH}`, { 
            stdio: 'inherit'
          });
        }
      }
      
      console.log('‚úÖ Database reset successful');
      return true;
    } finally {
      // Clean up SQL file
      if (fs.existsSync(sqlPath)) {
        fs.unlinkSync(sqlPath);
      }
    }
  } catch (error) {
    console.error('‚ùå Error resetting database:', error);
    return false;
  }
}

/**
 * Deploys the schema to the database
 */
function deploySchema() {
  try {
    // Generate Prisma client
    console.log('üîß Generating Prisma client...');
    execSync('npx prisma generate', { stdio: 'inherit' });
    
    // Push the schema directly to the database (more reliable)
    console.log('üöÄ Pushing schema to database...');
    try {
      execSync('npx prisma db push --accept-data-loss', { stdio: 'inherit' });
      console.log('‚úÖ Schema push completed');
      return true;
    } catch (pushError) {
      console.error('‚ùå Schema push failed, falling back to migrate deploy');
      
      // Fall back to migrate deploy
      try {
        execSync('npx prisma migrate deploy', { stdio: 'inherit' });
        console.log('‚úÖ Migration deploy completed');
        return true;
      } catch (migrateError) {
        console.error('‚ùå Migration deploy failed:', migrateError);
        return false;
      }
    }
  } catch (error) {
    console.error('‚ùå Error deploying schema:', error);
    return false;
  }
}

/**
 * Deploys the schema to the database safely preserving all data
 * Uses migrate dev in development and migrate deploy in production
 */
function deploySchemaSafely() {
  try {
    // Generate Prisma client
    console.log('üîß Generating Prisma client...');
    execSync('npx prisma generate', { stdio: 'inherit' });

    // Use the migration flow that preserves data
    console.log('üöÄ Deploying schema changes while preserving data...');

    if (IS_VERCEL) {
      // In production use migrate deploy which is safer for production data
      console.log('üîí Using prisma migrate deploy for production environment...');
      try {
        execSync('npx prisma migrate deploy', { stdio: 'inherit' });
        console.log('‚úÖ Migration deploy completed successfully');
        return true;
      } catch (migrateError) {
        console.error('‚ùå Migration deploy failed:', migrateError);
        return false;
      }
    } else {
      // In development use migrate dev with createOnly flag to create new migrations
      console.log('üîß Using prisma migrate dev for development environment...');
      try {
        execSync('npx prisma migrate dev --create-only', { stdio: 'inherit' });
        console.log('‚úÖ Migration development completed');
        return true;
      } catch (devError) {
        console.error('‚ùå Migration dev failed:', devError);
        return false;
      }
    }
  } catch (error) {
    console.error('‚ùå Error deploying schema safely:', error);
    return false;
  }
}

// Export all functions
module.exports = {
  validateEnvironment,
  validateSchema,
  resetMigrations,
  resetDatabase,
  deploySchema,
  deploySchemaSafely,
  IS_VERCEL
};