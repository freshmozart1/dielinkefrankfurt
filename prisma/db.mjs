/**
 * Prisma database utilities for development and production
 */
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const MIGRATIONS_DIR = path.join(__dirname, 'migrations');
const SCHEMA_PATH = path.join(__dirname, 'schema.prisma');
const IS_VERCEL = process.env.VERCEL === '1';

/**
 * Validates the database connection string and environment
 */
function validateEnvironment() {
  if (!process.env.DATABASE_URL) {
    console.error('‚ùå No DATABASE_URL found in environment');
    console.error('Please set the DATABASE_URL environment variable');
    return false;
  }

  // Check for either postgres:// or postgresql:// format
  if (!process.env.DATABASE_URL.includes('postgres')) {
    console.error('‚ùå DATABASE_URL does not appear to be a PostgreSQL connection string');
    console.error('Please ensure your PostgreSQL connection string is correctly formatted');
    return false;
  }

  console.log('‚úÖ DATABASE_URL is properly set');
  return true;
}

/**
 * Ensures the schema.prisma file has the correct provider settings
 */
function validateSchema() {
  try {
    console.log('üìù Validating schema.prisma configuration...');
    let schemaContent = fs.readFileSync(SCHEMA_PATH, 'utf8');
    let updated = false;

    // Ensure datasource provider is postgresql
    if (!schemaContent.includes('provider = "postgresql"')) {
      schemaContent = schemaContent.replace(
        /datasource\s+db\s*{[^}]*provider\s*=\s*".*?"/s,
        'datasource db {\n  provider = "postgresql"'
      );
      updated = true;
    }

    // Ensure generator provider is prisma-client-js
    if (!schemaContent.includes('provider = "prisma-client-js"')) {
      schemaContent = schemaContent.replace(
        /generator\s+client\s*{[^}]*provider\s*=\s*".*?"/s,
        'generator client {\n  provider = "prisma-client-js"'
      );
      updated = true;
    }

    // Write changes if needed
    if (updated) {
      fs.writeFileSync(SCHEMA_PATH, schemaContent);
      console.log('‚úÖ Updated schema.prisma configuration');
    } else {
      console.log('‚úÖ Schema configuration is valid');
    }
    
    return true;
  } catch (error) {
    console.error('‚ùå Error validating schema:', error);
    return false;
  }
}

/**
 * Resets and recreates all migrations
 */
function resetMigrations() {
  try {
    console.log('üîÑ Resetting migrations directory...');
    
    // Make sure migrations directory exists
    if (!fs.existsSync(MIGRATIONS_DIR)) {
      fs.mkdirSync(MIGRATIONS_DIR, { recursive: true });
    }
    
    // Remove all existing migrations (except lock file)
    const migrationFiles = fs.readdirSync(MIGRATIONS_DIR)
      .filter(file => file !== 'migration_lock.toml');
    
    for (const file of migrationFiles) {
      const filePath = path.join(MIGRATIONS_DIR, file);
      if (fs.lstatSync(filePath).isDirectory()) {
        fs.rmSync(filePath, { recursive: true, force: true });
      } else if (file !== 'migration_lock.toml') {
        fs.unlinkSync(filePath);
      }
    }

    // Create or update the migration_lock.toml file
    console.log('üìù Creating migration lock file for PostgreSQL...');
    fs.writeFileSync(
      path.join(MIGRATIONS_DIR, 'migration_lock.toml'),
      '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = "postgresql"\n'
    );

    // Create a new migration directory
    const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
    const newMigrationDir = path.join(MIGRATIONS_DIR, `${timestamp}_init`);
    
    if (!fs.existsSync(newMigrationDir)) {
      fs.mkdirSync(newMigrationDir, { recursive: true });
    }

    // Write the migration SQL
    fs.writeFileSync(
      path.join(newMigrationDir, 'migration.sql'),
      `-- CreateTable
CREATE TABLE IF NOT EXISTS "Appointment" (
    "id" SERIAL PRIMARY KEY,
    "teaser" TEXT NOT NULL,
    "mainText" TEXT NOT NULL,
    "startDateTime" TIMESTAMP(3) NOT NULL,
    "endDateTime" TIMESTAMP(3),
    "street" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "recurringText" TEXT,
    "fileUrls" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,
    "processingDate" TIMESTAMP(3)
);`
    );

    console.log('‚úÖ Fresh migration created at', newMigrationDir);
    return true;
  } catch (error) {
    console.error('‚ùå Error resetting migrations:', error);
    return false;
  }
}

/**
 * Attempts to reset the PostgreSQL database (drop and recreate schema)
 */
async function resetDatabase() {
  try {
    console.log('üóëÔ∏è Attempting to reset PostgreSQL database...');

    // Create a temporary file to execute SQL directly
    const sqlPath = path.join(__dirname, 'reset.sql');
    fs.writeFileSync(sqlPath, `
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO public;
    `);

    try {
      // For Vercel, we use Prisma directly since psql might not be available
      // For local development, we can try both approaches
      
      if (IS_VERCEL) {
        console.log('Using Prisma for database reset (Vercel environment)');
        
        // Create a minimal prisma schema for reset
        const tempSchemaPath = path.join(__dirname, 'temp-schema.prisma');
        fs.writeFileSync(tempSchemaPath, `
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
generator client {
  provider = "prisma-client-js"
  output   = "./temp-client"
}
        `);
        
        // Generate a temporary client
        execSync(`npx prisma generate --schema=${tempSchemaPath}`, { stdio: 'inherit' });
        
        // Create a temporary script to execute the reset
        const resetScriptPath = path.join(__dirname, 'temp-reset.js');
        fs.writeFileSync(resetScriptPath, `
const { PrismaClient } = require('./temp-client');
const prisma = new PrismaClient();

async function main() {
  try {
    await prisma.$executeRawUnsafe('DROP SCHEMA IF EXISTS public CASCADE');
    await prisma.$executeRawUnsafe('CREATE SCHEMA public');
    await prisma.$executeRawUnsafe('GRANT ALL ON SCHEMA public TO postgres');
    await prisma.$executeRawUnsafe('GRANT ALL ON SCHEMA public TO public');
    console.log('‚úÖ Database reset successful');
  } catch (error) {
    console.error('‚ùå Failed to reset database:', error.message);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

main();
        `);
        
        // Run the script
        execSync(`node ${resetScriptPath}`, { stdio: 'inherit' });
        
        // Clean up temp files
        fs.unlinkSync(tempSchemaPath);
        fs.unlinkSync(resetScriptPath);
        fs.rmSync(path.join(__dirname, 'temp-client'), { recursive: true, force: true });
      } else {
        // Try psql first for local development
        try {
          console.log('Attempting database reset via psql...');
          execSync(`psql "${process.env.DATABASE_URL}" -f "${sqlPath}"`, { stdio: 'inherit' });
        } catch (_psqlError) {
          console.log('psql not available, falling back to Prisma...');
          
          // Fall back to prisma db execute
          execSync(`npx prisma db execute --file=${sqlPath} --schema=${SCHEMA_PATH}`, { 
            stdio: 'inherit'
          });
        }
      }
      
      console.log('‚úÖ Database reset successful');
      return true;
    } finally {
      // Clean up SQL file
      if (fs.existsSync(sqlPath)) {
        fs.unlinkSync(sqlPath);
      }
    }
  } catch (error) {
    console.error('‚ùå Error resetting database:', error);
    return false;
  }
}

/**
 * Deploys the schema to the database
 */
function deploySchema() {
  try {
    // Generate Prisma client
    console.log('üîß Generating Prisma client...');
    execSync('npx prisma generate', { stdio: 'inherit' });
    
    // Push the schema directly to the database (more reliable)
    console.log('üöÄ Pushing schema to database...');
    try {
      execSync('npx prisma db push --accept-data-loss', { stdio: 'inherit' });
      console.log('‚úÖ Schema push completed');
      return true;
    } catch (_pushError) {
      console.error('‚ùå Schema push failed, falling back to migrate deploy');
      
      // Fall back to migrate deploy
      try {
        execSync('npx prisma migrate deploy', { stdio: 'inherit' });
        console.log('‚úÖ Migration deploy completed');
        return true;
      } catch (migrateError) {
        console.error('‚ùå Migration deploy failed:', migrateError);
        return false;
      }
    }
  } catch (error) {
    console.error('‚ùå Error deploying schema:', error);
    return false;
  }
}

/**
 * Creates a baseline migration if needed and marks it as applied
 */
function baselineDatabase() {
  try {
    console.log('üèÅ Checking if database needs to be baselined...');

    // Check if _prisma_migrations table exists
    const checkMigrationsTableCommand = IS_VERCEL
      ? `npx prisma db execute --file=${path.join(__dirname, 'check-migrations-table.sql')} --schema=${SCHEMA_PATH}`
      : `psql "${process.env.DATABASE_URL}" -c "SELECT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = '_prisma_migrations');"`;

    // Create SQL file to check for migrations table
    fs.writeFileSync(
      path.join(__dirname, 'check-migrations-table.sql'),
      `SELECT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = '_prisma_migrations');`
    );

    let migrationsTableExists = false;
    try {
      const result = execSync(checkMigrationsTableCommand, { stdio: 'pipe' }).toString();
      migrationsTableExists = result.includes('t') || result.includes('true');
    } catch (error) {
      console.log('Could not check migrations table, assuming it does not exist:', error.message);
    }

    // Clean up the SQL file
    try {
      fs.unlinkSync(path.join(__dirname, 'check-migrations-table.sql'));
    } catch (error) {
      console.log('Could not delete check-migrations-table.sql:', error.message);
    }

    // If migrations table doesn't exist but database has tables, we need to baseline
    if (!migrationsTableExists) {
      console.log('üèÅ Migration table not found, initializing baseline migration...');

      // Create baseline migration
      const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
      const baselineMigrationDir = path.join(MIGRATIONS_DIR, `${timestamp}_baseline`);

      if (!fs.existsSync(baselineMigrationDir)) {
        fs.mkdirSync(baselineMigrationDir, { recursive: true });
      }

      // Get current schema from database
      fs.writeFileSync(
        path.join(baselineMigrationDir, 'migration.sql'),
        `-- CreateTable
CREATE TABLE IF NOT EXISTS "Appointment" (
    "id" SERIAL PRIMARY KEY,
    "teaser" TEXT NOT NULL,
    "mainText" TEXT NOT NULL,
    "startDateTime" TIMESTAMP(3) NOT NULL,
    "endDateTime" TIMESTAMP(3),
    "street" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "recurringText" TEXT,
    "fileUrls" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,
    "processingDate" TIMESTAMP(3)
);

-- CreateMigrationsTable
-- This is needed for migration history tracking
CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
    "id" VARCHAR(36) NOT NULL,
    "checksum" VARCHAR(64) NOT NULL,
    "finished_at" TIMESTAMPTZ,
    "migration_name" VARCHAR(255) NOT NULL,
    "logs" TEXT,
    "rolled_back_at" TIMESTAMPTZ,
    "started_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
    "applied_steps_count" INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY ("id")
);
`
      );

      console.log('‚úÖ Created baseline migration at', baselineMigrationDir);

      // Mark the baseline migration as applied
      if (IS_VERCEL) {
        try {
          // Get migration name directly
          const migrationName = path.basename(baselineMigrationDir);
          console.log(`üèÅ Creating baseline migration: ${migrationName}`);

          // Create SQL directly to mark migration as applied
          const sqlPath = path.join(__dirname, 'mark-migration-applied.sql');
          fs.writeFileSync(sqlPath, `
-- Create migrations table if it doesn't exist
CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
    "id" VARCHAR(36) NOT NULL,
    "checksum" VARCHAR(64) NOT NULL,
    "finished_at" TIMESTAMPTZ,
    "migration_name" VARCHAR(255) NOT NULL,
    "logs" TEXT,
    "rolled_back_at" TIMESTAMPTZ,
    "started_at" TIMESTAMPTZ NOT NULL DEFAULT now(),
    "applied_steps_count" INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY ("id")
);

-- Insert our migration as applied
INSERT INTO "_prisma_migrations" ("id", "checksum", "finished_at", "migration_name", "logs", "rolled_back_at", "started_at", "applied_steps_count")
VALUES (
    md5(random()::text || clock_timestamp()::text)::uuid, -- random UUID
    md5('${migrationName}'), -- checksum based on migration name
    NOW(), -- finished_at
    '${migrationName}', -- migration_name
    NULL, -- logs
    NULL, -- rolled_back_at
    NOW(), -- started_at
    1 -- applied_steps_count
);
`);

          // Execute SQL directly
          try {
            execSync(`npx prisma db execute --file=${sqlPath} --schema=${SCHEMA_PATH}`, { stdio: 'inherit' });
            console.log('‚úÖ Marked baseline migration as applied');

            // Clean up
            if (fs.existsSync(sqlPath)) {
              fs.unlinkSync(sqlPath);
            }
          } catch (error) {
            console.error('‚ùå Error marking migration as applied:', error);
            return false;
          }
        } catch (error) {
          console.error('‚ùå Error marking baseline migration as applied:', error);
          return false;
        }
      }

      console.log('‚úÖ Database baseline completed');
    } else {
      console.log('‚úÖ Migrations table already exists, skipping baseline');
    }

    return true;
  } catch (error) {
    console.error('‚ùå Error creating baseline:', error);
    return false;
  }
}

/**
 * Deploys the schema to the database safely preserving all data
 * Uses migrate dev in development and migrate deploy in production
 */
function deploySchemaSafely() {
  try {
    // Generate Prisma client
    console.log('üîß Generating Prisma client...');
    execSync('npx prisma generate', { stdio: 'inherit' });

    // Ensure database has a baseline if needed
    if (!baselineDatabase()) {
      console.error('‚ùå Failed to baseline database');
      return false;
    }

    // Use the migration flow that preserves data
    console.log('üöÄ Deploying schema changes while preserving data...');

    if (IS_VERCEL) {
      // In production use db push for first deployment after baselining
      // This is safer since we've already baselined the database
      console.log('üîí Using prisma db push for production environment...');
      try {
        execSync('npx prisma db push --accept-data-loss', { stdio: 'inherit' });
        console.log('‚úÖ Schema push completed successfully');
        return true;
      } catch (pushError) {
        console.error('‚ùå Schema push failed, trying migrate deploy:', pushError);

        // Fall back to migrate deploy
        try {
          console.log('üîí Using prisma migrate deploy for production environment...');
          execSync('npx prisma migrate deploy', { stdio: 'inherit' });
          console.log('‚úÖ Migration deploy completed successfully');
          return true;
        } catch (migrateError) {
          console.error('‚ùå Migration deploy failed:', migrateError);
          return false;
        }
      }
    } else {
      // In development use migrate dev with createOnly flag to create new migrations
      console.log('üîß Using prisma migrate dev for development environment...');
      try {
        execSync('npx prisma migrate dev --create-only', { stdio: 'inherit' });
        console.log('‚úÖ Migration development completed');
        return true;
      } catch (devError) {
        console.error('‚ùå Migration dev failed:', devError);
        return false;
      }
    }
  } catch (error) {
    console.error('‚ùå Error deploying schema safely:', error);
    return false;
  }
}

// Export all functions
export {
  validateEnvironment,
  validateSchema,
  resetMigrations,
  resetDatabase,
  deploySchema,
  baselineDatabase,
  deploySchemaSafely,
  IS_VERCEL
};