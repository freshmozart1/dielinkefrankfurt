# Data Model: Appointment Link Enhancement

**Phase**: 1 (Design)
**Date**: 2025-10-26
**Purpose**: Document database schema changes for slug support in Appointment model

---

## Overview

This feature adds a single optional field to the existing `Appointment` model to store URL-friendly slugs. The field is nullable to support backwards compatibility with existing appointments.

---

## Schema Changes

### Modified Model: Appointment

**File**: `/home/paw/nextjs/dielinkefrankfurt/prisma/schema.prisma`

#### New Field

```prisma
model Appointment {
  // ... existing fields ...

  // NEW: URL-friendly slug for pretty URLs
  slug               String?   // Optional slug generated from title

  // ... existing system fields ...

  @@index([slug]) // NEW: Index for potential slug-based lookups
  @@map("appointment")
}
```

#### Complete Field Definition

```prisma
model Appointment {
  // Identifiers and core fields
  id             Int       @id @default(autoincrement())
  title          String
  mainText       String

  // Date and time information
  startDateTime  DateTime
  endDateTime    DateTime?

  // Location information
  street         String?
  city           String?
  locationDetails String?   @map("location_details")
  postalCode     String?

  // Requester information
  firstName      String?
  lastName       String?

  // Additional details
  recurringText  String?
  fileUrls       String?
  featured       Boolean   @default(false)
  metadata       String?

  // NEW: Slug for SEO-friendly URLs
  slug           String?   // Generated once on acceptance, never regenerated

  // System fields
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  processed        Boolean   @default(false)
  processingDate   DateTime?
  statusChangeDate DateTime?

  // Appointment status
  status           String    @default("pending")
  rejectionReason  String?

  @@index([processed])
  @@index([status])
  @@index([featured])
  @@index([slug])        // NEW: Index for slug-based queries
  @@map("appointment")
}
```

### Field Specifications

| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
| `slug` | String | Yes | NULL | URL-friendly slug generated from title on acceptance |

#### Field Constraints
- **Max length**: ~100 characters (PostgreSQL default VARCHAR)
- **Format**: Lowercase alphanumeric + hyphens, format: `{id}-{title-slug}`
- **Uniqueness**: NOT unique constraint (ID prefix ensures practical uniqueness)
- **Indexing**: Indexed for potential slug-based lookups (optional performance optimization)

#### Field Behavior
- **When set**: Generated once when appointment status changes to "accepted"
- **Immutability**: Once set, never regenerated (even if title changes)
- **Null handling**: NULL for existing appointments (backwards compatibility)
- **Generation failure**: Remains NULL if slug generation fails (acceptance still succeeds)

---

## Migration Strategy

### Database Migration

Since the new field is nullable, no data migration is required. Existing appointments will have `slug = NULL`.

**Migration Steps**:
1. Add `slug String?` field to Prisma schema
2. Add index on `slug` field
3. Run `npm run db:push` to apply schema change
4. No data backfill required (slugs generated on-demand for new acceptances)

**SQL Preview** (generated by Prisma):
```sql
-- Add slug column
ALTER TABLE "appointment" ADD COLUMN "slug" VARCHAR;

-- Add index on slug
CREATE INDEX "appointment_slug_idx" ON "appointment"("slug");
```

### Backwards Compatibility

| Scenario | Behavior |
|----------|----------|
| Existing appointment (slug = NULL) | Accessible via numeric URL `/termine/{id}` |
| Newly accepted appointment (slug set) | Accessible via both `/termine/{id}` and `/termine/{id}-{slug}` |
| Appointment with wrong slug | Works (routing extracts ID only) |
| Slug generation fails | Appointment still accepted, slug remains NULL |

---

## Data Flow

### Slug Generation Timeline

```
1. User submits appointment
   └─> status: "pending", slug: NULL

2. Admin reviews appointment
   └─> Admin clicks "Akzeptieren"

3. API endpoint processes acceptance
   ├─> Fetch appointment from database
   ├─> Generate slug from title + ID
   │   └─> On failure: log error, continue with slug = NULL
   └─> Update appointment:
       ├─> status: "accepted"
       ├─> statusChangeDate: now()
       └─> slug: generated_slug (or NULL on failure)

4. Appointment available at URLs:
   ├─> /termine/{id} (always works)
   └─> /termine/{id}-{slug} (if slug not NULL)
```

### Slug Usage in Application

```typescript
// Database query (primary method - by ID)
const appointment = await findAppointmentById(123);

// Optional: Query by slug (for future features)
const appointment = await prisma.appointment.findFirst({
  where: { slug: '123-vollversammlung-oktober' }
});

// Generate public URL
const publicUrl = appointment.slug
  ? `/termine/${appointment.slug}`  // New format
  : `/termine/${appointment.id}`;   // Legacy format
```

---

## Type Definitions

### Prisma Generated Type

```typescript
// Generated by Prisma Client
export type Appointment = {
  id: number;
  title: string;
  mainText: string;
  startDateTime: Date;
  endDateTime: Date | null;
  street: string | null;
  city: string | null;
  locationDetails: string | null;
  postalCode: string | null;
  firstName: string | null;
  lastName: string | null;
  recurringText: string | null;
  fileUrls: string | null;
  featured: boolean;
  metadata: string | null;
  slug: string | null;  // NEW field
  createdAt: Date;
  updatedAt: Date;
  processed: boolean;
  processingDate: Date | null;
  statusChangeDate: Date | null;
  status: string;
  rejectionReason: string | null;
};
```

### Custom Type Extensions

**File**: `/home/paw/nextjs/dielinkefrankfurt/src/types/api-types.ts`

```typescript
/**
 * Metadata for appointment Open Graph tags
 */
export interface AppointmentMetadata {
  title: string;
  description: string;
  imageUrl: string;
  url: string;
  startDateTime: string; // ISO 8601
  endDateTime?: string; // ISO 8601
  location?: string;
}

/**
 * Result of slug generation operation
 */
export interface SlugGenerationResult {
  slug: string;
  success: boolean;
  error?: string;
}
```

---

## Database Operations

### New/Modified Operations

**File**: `/home/paw/nextjs/dielinkefrankfurt/src/lib/db/appointment-operations.ts`

#### Modified: updateAppointmentById

```typescript
/**
 * Updates an existing appointment (including slug field).
 *
 * @param id - Appointment ID
 * @param data - Update data (may include slug)
 * @returns Promise resolving to updated appointment
 */
export async function updateAppointmentById(
  id: number,
  data: Prisma.AppointmentUpdateInput
): Promise<Appointment> {
  // Implementation already exists, automatically handles slug field
  try {
    const appointment = await prisma.appointment.update({
      where: { id },
      data
    });

    logger.info('Appointment updated in database', {
      module: 'db/appointment-operations',
      context: { id: appointment.id }
    });

    return appointment;
  } catch (error) {
    logger.error('Error updating appointment', {
      module: 'db/appointment-operations',
      context: { id, error }
    });
    throw error;
  }
}
```

#### Optional: findAppointmentBySlug

```typescript
/**
 * Finds a single appointment by slug.
 * Optional operation for future slug-based routing enhancements.
 *
 * @param slug - Appointment slug
 * @returns Promise resolving to appointment or null if not found
 */
export async function findAppointmentBySlug(slug: string): Promise<Appointment | null> {
  try {
    return await prisma.appointment.findFirst({
      where: { slug }
    });
  } catch (error) {
    logger.error('Error finding appointment by slug', {
      module: 'db/appointment-operations',
      context: { slug, error }
    });
    throw error;
  }
}
```

**Note**: This operation is optional. The current implementation extracts ID from URL params and uses `findAppointmentById()`.

---

## Testing Checklist

### Database Schema Validation

- [ ] Run `npm run db:push` successfully
- [ ] Verify `slug` column exists in PostgreSQL: `\d appointment`
- [ ] Verify index exists: `\di appointment_slug_idx`
- [ ] Verify existing appointments have `slug = NULL`
- [ ] Verify schema allows NULL values (no constraint errors)

### Data Operations

- [ ] Create new appointment → slug should be NULL
- [ ] Accept appointment → slug should be generated and stored
- [ ] Query appointment by ID → returns appointment with slug field
- [ ] Update appointment title → slug remains unchanged (immutability)
- [ ] Delete appointment → works as before (no cascade issues)

### Edge Cases

- [ ] Accept appointment with empty title → slug uses fallback format
- [ ] Accept appointment with emoji title → slug removes emojis
- [ ] Accept appointment with very long title → slug truncated to 50 chars
- [ ] Slug generation throws error → appointment still accepts, slug remains NULL
- [ ] Two appointments with same title → slugs are unique (ID prefix)

---

## Performance Impact

### Storage
- **Field size**: ~50-100 bytes per appointment (VARCHAR)
- **Index size**: ~100 bytes per appointment
- **Total impact**: ~150 bytes × 500 appointments = 75KB (negligible)

### Query Performance
- **Indexed slug lookups**: O(log n) with B-tree index
- **Impact on existing queries**: None (slug not used in current queries)
- **Write performance**: Negligible (<1ms per insert/update)

---

## Security Considerations

### SQL Injection
- **Risk**: Low (Prisma ORM handles parameterization)
- **Validation**: Slug format enforced by generation utility (alphanumeric + hyphens only)

### Data Integrity
- **NULL handling**: Application code handles NULL slugs gracefully
- **Immutability**: Once set, slug never changes (prevents URL breakage)
- **Uniqueness**: ID prefix ensures practical uniqueness (no unique constraint needed)

### Privacy
- **No PII**: Slug derived from public appointment title (no privacy concerns)
- **Public visibility**: Slug appears in public URLs (same as title)

---

## Rollback Plan

If issues arise, the field can be safely removed:

```sql
-- Remove index
DROP INDEX IF EXISTS "appointment_slug_idx";

-- Remove column
ALTER TABLE "appointment" DROP COLUMN "slug";
```

**Note**: This is non-destructive (slug is optional). Existing code works with or without the field due to nullable type.

---

## Future Enhancements

### Potential Optimizations

1. **Unique slug constraint**: Add unique constraint if slug-based routing becomes primary method
   ```prisma
   slug String? @unique
   ```

2. **Slug backfill**: Generate slugs for existing accepted appointments
   ```typescript
   // One-time migration script
   const appointments = await prisma.appointment.findMany({
     where: { status: 'accepted', slug: null }
   });

   for (const appt of appointments) {
     const slug = generateAppointmentSlug(appt.title, appt.id);
     await updateAppointmentById(appt.id, { slug });
   }
   ```

3. **Slug-based canonical URLs**: Redirect numeric URLs to slug URLs (SEO enhancement)
   ```typescript
   // In page.tsx
   if (appointment.slug && !params.id.includes('-')) {
     redirect(`/termine/${appointment.slug}`);
   }
   ```

**Decision**: These enhancements are out of scope for MVP. Implement KISS approach first.

---

## References

- Prisma Schema Reference: https://www.prisma.io/docs/concepts/components/prisma-schema
- PostgreSQL VARCHAR Type: https://www.postgresql.org/docs/current/datatype-character.html
- PostgreSQL Indexes: https://www.postgresql.org/docs/current/indexes.html
- Project Constitution: `/home/paw/nextjs/dielinkefrankfurt/.specify/memory/constitution.md`
